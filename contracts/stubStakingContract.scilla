(* StubStakingContract contract *)

scilla_version 0

import ListUtils IntUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library StubStakingContract

(* SSN Data Type https://github.com/Zilliqa/staking-contract/blob/main/contracts/ssnlist.scilla#L8 *)
(* Each SSN has the following fields: *)
(* ActiveStatus      : Bool *)
(* BufferedDeposit   : Uint128 *)
(*                     Stake deposit that cannot be counted as a part of reward calc. for the ongoing reward cycle. But, to be considered *)
(*                     for the next one. *)

type Ssn =
| Ssn of Bool Uint128


let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let uint128_zero = Uint128 0
let uint32_one = Uint32 1
let bool_active = True
let bool_inactive = False
let addfunds_tag = "AddFunds"

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract StubStakingContract()

field implementation: ByStr20 = _this_address
field bnum_req: Uint128 = Uint128 35000

(* Keeps track of SSNS *)
(* AddressOfSSN -> SSNInfo *)
field ssnlist: Map ByStr20 Ssn = Emp ByStr20 Ssn

(* AddressOfDeleg -> BlockNumber -> Deposit *)
field withdrawal_pending: Map ByStr20 (Map BNum Uint128) = Emp ByStr20 (Map BNum Uint128)

field available_withdrawal: Uint128 = uint128_zero
field current_deleg: Option ByStr20 = None {ByStr20}

field lastrewardcycle: Uint32 = uint32_one
field totalstakeamount: Uint128 = uint128_zero

(* Keeps track of buffered deposit for a delegator *)
(* AddressOfDeleg -> (AddressofSSN -> (RewardCycleNumber -> BufferedStakeAmountDuringTheCycle)) *)
(* The BufferedStakeAmount will only be truely delegated at next cycle *)
(* seems this field used only when delegator withdrawing rewards, then it will be cleared *)
(* so we don't touch it during Verifier->AssignStakeReward *)
field buff_deposit_deleg: Map ByStr20 (Map ByStr20 (Map Uint32 Uint128)) = Emp ByStr20 (Map ByStr20 (Map Uint32 Uint128))

(***************************************************)
(*              Procedures                         *)
(***************************************************)

procedure AddsSSN(ssnaddr: ByStr20, status: Bool, buff_deposit: Uint128)
  s = Ssn status buff_deposit;
  ssnlist[ssnaddr] := s
end

procedure IncreaseTotalStakeAmt(amt: Uint128)
  current_amt <- totalstakeamount;
  new_amt = builtin add current_amt amt;
  totalstakeamount := new_amt
end

procedure DecreaseTotalStakeAmt(amt: Uint128)
  current_amt <- totalstakeamount;
  new_amt = builtin sub current_amt amt;
  totalstakeamount := new_amt
end

procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
    msg = {_tag: tag; _recipient: recipient; _amount: amt};
    msgs = one_msg msg;
    send msgs
end

(* delete the blk num and any other external keys if the inner map is empty *)
(* for use in replace of normal delete operation to erase empty nested maps *)
procedure DeletePendingWithdrawal(deleg: ByStr20, withdraw_number: BNum)
  delete withdrawal_pending[deleg][withdraw_number]
  (* CleanPendingWithdrawalDelegAddr deleg *)
end

(* current_block > withdraw_number + bnum_req *)
procedure CalculateTotalWithdrawal(withdraw: Pair BNum Uint128)
  current_deleg_o <- current_deleg;
  match current_deleg_o with
  | Some deleg =>
    match withdraw with
    | Pair withdraw_number amt =>
      current_bnum <- & BLOCKNUMBER;
      current_bnum_req <- bnum_req;
      bnum = builtin badd withdraw_number current_bnum_req;
      can_withdraw = builtin blt bnum current_bnum;
      match can_withdraw with
      | True =>
          DeletePendingWithdrawal deleg withdraw_number;
          current_amt <- available_withdrawal;
          current_amt = builtin add current_amt amt;
          available_withdrawal := current_amt
      | False =>
      end
    end
  | None => (* Won't reach *)
  end
end

procedure Delegate(ssnaddr: ByStr20, initiator: ByStr20, amount: Uint128)
  lrc <- lastrewardcycle;

  curval <- ssnlist[ssnaddr];
  match curval with
  | Some (Ssn status buffdeposit) =>

    (* The SSN is active so add the delegated stake to the buffer *)
    (* @fixme Do we need this in stub contract ? last_buf_deposit_cycle_deleg[initiator][ssnaddr] := lrc; *)
    new_buff_amt = builtin add amount buffdeposit;
    ssn = Ssn bool_active new_buff_amt;
    ssnlist[ssnaddr] := ssn;

    (* record this to buffer deposit for deleg *)
    stake_amt_for_deleg_option <- buff_deposit_deleg[initiator][ssnaddr][lrc];
    match stake_amt_for_deleg_option with
    | Some stake_amt_for_deleg =>
      new_stake_amt_for_deleg = builtin add stake_amt_for_deleg amount;
      buff_deposit_deleg[initiator][ssnaddr][lrc] := new_stake_amt_for_deleg
    | None =>
      buff_deposit_deleg[initiator][ssnaddr][lrc] := amount
    end
  | None =>
    e = { _exception : "SsnNotExists"; ssnaddr : ssnaddr };
    throw e
  end

end

(* https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla#L996 *)
(* We're supposing that SSN is active, so just substract undeleg_amt from totalstakeamount *)
procedure UnDelegateStakeAmt(initiator: ByStr20, ssn: ByStr20, undeleg_amt: Uint128)
  DecreaseTotalStakeAmt undeleg_amt;
  event_decrease = { _eventname: "DecreaseTotalStakeAmt"; decreased_amt: undeleg_amt };
  event event_decrease
end

(* https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla#L1036 *)
procedure WithdrawalStakeAmt(initiator: ByStr20, ssn: ByStr20, withdraw_amount: Uint128)
  withdrawal_bnum <- & BLOCKNUMBER;
  withdraw_amt_o <- withdrawal_pending[initiator][withdrawal_bnum];
  withdraw_amt_pending = match withdraw_amt_o with
  | Some v => builtin add v withdraw_amount
  | None => withdraw_amount
  end;
  withdrawal_pending[initiator][withdrawal_bnum] := withdraw_amt_pending;

  e = { _eventname: "Deleg withdraw deposit"; ssn_addr: ssn; deleg_address: initiator; withdraw_amount: withdraw_amount };
  event e;

  DecreaseTotalStakeAmt withdraw_amount;
  event_decrease = { _eventname: "DecreaseTotalStakeAmt"; decreased_amt: withdraw_amount };
  event event_decrease
end

(* custom procedure, partially based on UpdateStakeReward *)
procedure SsnBufferToStake (ssn: Pair ByStr20 Ssn)
  match ssn with
  | Pair ssnaddr ssninfo =>
    lastreward_blk <- lastrewardcycle;
    match ssninfo with
    | Ssn active_status buffdeposit =>
      (* Update ssn info *)
      new_buffdeposit = uint128_zero;
      ssninfo = Ssn active_status new_buffdeposit;
      ssnlist[ssnaddr] := ssninfo;
      IncreaseTotalStakeAmt buffdeposit;
      e = { _eventname: "SSN assign reward"; ssnaddr: ssnaddr; cycle_number: lastreward_blk; delegate_rewards: uint128_zero; comm_rewards: uint128_zero};
      event e
    end
  end
end

(************************************************************)
(* @dev: Admin transitions                                  *)
(************************************************************)

(* https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla#L1335 *)
(* @dev : To add SSN for testing purposes *)
(* @param ssnaddr: SSN address *)
transition AddSSN(ssnaddr: ByStr20)
  status = bool_inactive;
  buff_deposit = uint128_zero;
  AddsSSN ssnaddr status buff_deposit;
  e = { _eventname: "SSN added"; ssn_addr: ssnaddr };
  event e
end

transition ChangeBNumReq(input_bnum_req: Uint128)
  bnum_req := input_bnum_req
end

(************************************************************)
(* @dev: Verifier transitions                               *)
(************************************************************)

(* https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla#L1654 *)
(* Parameters differs from original, because we don't assign rewards here really, we just need to transfer buffered deposits to stake for each SSN *)

transition AssignStakeReward()
  accept;
  cur_ssn_map <- ssnlist;
  (* ssnlist map to list of pairs *)
  cur_ssn_list = builtin to_list cur_ssn_map;
  forall cur_ssn_list SsnBufferToStake;

  (* move to the next cycle *)
  lrc <- lastrewardcycle;
  newLastRewardCycleNum = builtin add uint32_one lrc;
  lastrewardcycle := newLastRewardCycleNum
end

(************************************************************)
(* @dev: Delegator transitions                              *)
(************************************************************)

(* https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla#L1535 *)
(* @dev : To delegate the stake to the contract. *)
(* @param ssnaddr: The address of the SSN to which the deleg wants to stake *)
transition DelegateStake(ssnaddr: ByStr20)
  (* Accept the deposit from SSN and add to contract balance. *)
  accept;
  amount = _amount;
  initiator = _sender;

  Delegate ssnaddr initiator amount;
  e = { _eventname: "DelegateStake"; ssn_addr: ssnaddr; delegator: initiator; amount: amount };
  event e;
  msg_to_delegator = {
    _tag : "DelegateStakeSuccessCallBack";
    _recipient : initiator;
    _amount : uint128_zero;
    ssnaddr : ssnaddr;
    amount : amount
  };
  msg = one_msg msg_to_delegator;
  send msg
end

(* https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla#L1560 *)
(* @dev: Intitiate the process of unbonding of ZIL for withdrawal purpose. Used by delegs. *)
(* @param ssnaddr: Address of the SSN to which stake had been delegated. *)
(* @param amt: The amount which the delegators want to unbond*)
transition WithdrawStakeAmt(ssnaddr: ByStr20, amt: Uint128)
  initiator = _sender;
  WithdrawalStakeAmt initiator ssnaddr amt;
  msg_to_delegator = {_tag : "WithdrawStakeAmtSuccessCallBack"; _recipient : initiator; _amount : uint128_zero;
  ssnaddr : ssnaddr; amount : amt};
  msg = one_msg msg_to_delegator;
  send msg
end

transition CompleteWithdrawal()
  initiator = _sender;
  withdraw_map_o <- withdrawal_pending[initiator];
  match withdraw_map_o with
  | Some withdraw_map =>
    withdraw_list = builtin to_list withdraw_map;
    (* To init tmp fields *)
    withdrawal_zero = uint128_zero;
    available_withdrawal := withdrawal_zero;
    c = Some {ByStr20} initiator;
    current_deleg := c;

    (* Calculate withdrawal that can be transferred *)
    forall withdraw_list CalculateTotalWithdrawal;
    withdraw_amt <- available_withdrawal;
    transfer = builtin eq withdraw_amt uint128_zero;
    match transfer with
    | True =>
      e = { _eventname: "NoUnbondedStake"; ssnaddr: initiator };
      event e;
      msg_to_delegator = {_tag : "CompleteWithdrawalNoUnbondedStakeCallBack"; _recipient : initiator; _amount : uint128_zero;
      amount : uint128_zero};
      msg = one_msg msg_to_delegator;
      send msg
    | False =>
      e = { _eventname: "CompleteWithdrawal"; ssnaddr: initiator; amount: withdraw_amt };
      event e;
      TransferFunds addfunds_tag withdraw_amt initiator;
      msg_to_delegator = {_tag : "CompleteWithdrawalSuccessCallBack"; _recipient : initiator; _amount : uint128_zero;
      amount : withdraw_amt};
      msg = one_msg msg_to_delegator;
      send msg
    end
  | None =>
    e = { _eventname: "NoPendingWithdrawal"; ssnaddr: initiator };
    event e
  end
end

transition WithdrawStakeRewards(ssnaddr: ByStr20)
  initiator = _sender;

  (* Staticly withdraw 1 ZIL *)
  reward = Uint128 1000000000000;
  TransferFunds addfunds_tag reward initiator;

  msg_to_delegator = {_tag : "WithdrawStakeRewardsSuccessCallBack"; _recipient : initiator; _amount : uint128_zero;
  ssnaddr : ssnaddr; rewards : reward};
  msg = one_msg msg_to_delegator;
  send msg
end
