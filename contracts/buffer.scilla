scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
library Buffer

let uint128_zero = Uint128 0

type Error =
  | AimplValidationFailed
  | AdminValidationFailed
  | ClaimRewardsHolderFundsMismatch

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | AimplValidationFailed => Int32 -401
      | AdminValidationFailed => Int32 -402
      | ClaimRewardsHolderFundsMismatch => Int32 -403
      end
    in
    { _exception: "Error"; code: result_code }

let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Buffer(
  init_admin_address                  : ByStr20,
  init_azil_ssn_address               : ByStr20,
  init_aimpl_address                  : ByStr20,
  init_proxy_staking_contract_address : ByStr20
)
(*  Parameters *)

(* Mutable fields *)
field contractadmin_address           : ByStr20 = init_admin_address
field azil_ssn_address                : ByStr20 = init_azil_ssn_address
field aimpl_address                   : ByStr20 = init_aimpl_address
field proxy_staking_contract_address  : ByStr20 = init_proxy_staking_contract_address

field tmp_added_funds: Uint128 = uint128_zero

(************************************************************)
(* @dev: Procedures                                         *)
(************************************************************)

procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

(* Check if the caller is the azil implementation contract*)
procedure IsAimpl()
  var_aimpl_address <- aimpl_address;
  is_aimpl = builtin eq _sender var_aimpl_address;
  match is_aimpl with
  | True  =>
  | False =>
    e = AimplValidationFailed;
    ThrowError e
  end
end

procedure IsAdmin(initiator: ByStr20)
  contractadmin_tmp <- contractadmin_address;
  is_admin = builtin eq initiator contractadmin_tmp;
  match is_admin with
  | True  =>
  | False =>
    e = AdminValidationFailed;
    ThrowError e
  end
end

(* @dev : To delegate the stake to the contract. *)
(* @param ssnaddr: The address of the SSN to which the deleg wants to stake *)
procedure ProxyDelegate(ssnaddr: ByStr20, proxy_contract_addr: ByStr20, amount: Uint128)
  msg = {_tag: "DelegateStake"; _recipient: proxy_contract_addr; _amount: amount; ssnaddr: ssnaddr};
  msgs = one_msg msg;
  send msgs
end

(* @dev : To claim rewards *)
(* @param ssnaddr: The address of the SSN to which the deleg wants to stake *)
procedure ProxyWithdrawStakeRewards(ssnaddr: ByStr20, proxy_contract_addr: ByStr20)
  msg = {_tag: "WithdrawStakeRewards"; _recipient: proxy_contract_addr; _amount: uint128_zero; ssnaddr: ssnaddr};
  msgs = one_msg msg;
  send msgs
end

(************************************************************)
(* @dev: Admin actions                                      *)
(************************************************************)

transition ChangeAzilSSNAddress(address: ByStr20)
  initiator = _sender;
  IsAdmin initiator;
  azil_ssn_address := address;
  e = { _eventname: "ChangeAzilSSNAddress"; address: address };
  event e
end

transition ChangeAimplAddress(address: ByStr20)
  initiator = _sender;
  IsAdmin initiator;
  aimpl_address := address;
  e = { _eventname: "ChangeAimplAddress"; address: address };
  event e
end

transition ChangeProxyStakingContractAddress(address: ByStr20)
  initiator = _sender;
  IsAdmin initiator;
  proxy_staking_contract_address := address;
  e = { _eventname: "ChangeProxyStakingContractAddress"; address: address };
  event e
end

(************************************************************)
(* @dev: IsZimpl actions                                    *)
(************************************************************)

transition AddFunds()
  (* TODO: IsZimpl; ? *)
  accept;
  tmp_added_funds := _amount
end

(************************************************************)
(* @dev: Deposit undelegated zil, use our node              *)
(************************************************************)
transition DelegateStake()
  IsAimpl;
  accept;
  stake_amt = _amount;

  ssnaddr <- azil_ssn_address;
  proxy_staking_contract_addr <- proxy_staking_contract_address;

  ProxyDelegate ssnaddr proxy_staking_contract_addr stake_amt
end

transition DelegateStakeSuccessCallBack(ssnaddr: ByStr20, amount: Uint128)
  (* We ignore the staking contract callbacks *)
end

transition ClaimRewards()
  IsAimpl;
  tmp_added_funds := uint128_zero;

  ssnaddr <- azil_ssn_address;
  proxy_staking_contract_addr <- proxy_staking_contract_address;

  ProxyWithdrawStakeRewards ssnaddr proxy_staking_contract_addr
end

transition WithdrawStakeRewardsSuccessCallBack(ssnaddr: ByStr20, rewards: Uint128)
  (* TODO: IsZimpl; ? *)
  added_funds <- tmp_added_funds;

  (* reset tmp variable *)
  tmp_added_funds := uint128_zero;

  (* check that Zimpl sent us correct data *)
  amount_eq = builtin eq added_funds rewards;
  match amount_eq with
  | False =>
    e = ClaimRewardsHolderFundsMismatch;
    ThrowError e
  | True =>
    o_aimpl_address <- aimpl_address;

    msg = { _tag : "ClaimRewardsSuccessCallBack"; _recipient : o_aimpl_address; _amount : rewards };
    msgs = one_msg msg;
    send msgs
  end
end
