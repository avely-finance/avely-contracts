scilla_version 0

import ListUtils IntUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library AZil

type Withdrawal =
  | Withdrawal of Uint128 Uint128

type Error =
  | ReDelegInvalidSSNAddr
  | DelegDoesNotExistAtSSN
  | InvalidTotalAmt
  | DelegHasNoSufficientAmt
  | DelegStakeNotEnough
  | CantFetchRemoteImplAddr
  | CantFetchRemoteBnumReq
<<<<<<< HEAD
  | CompleteWithdrawalFundsMismatchAtZimpl
  | CompleteWithdrawalFundsZeroAtZimpl
  | CompleteWithdrawalFundsMismatchAimplZimpl
=======
  | NoActiveBuffer
>>>>>>> main

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | DelegDoesNotExistAtSSN => Int32 -7
      | DelegHasNoSufficientAmt => Int32 -13
      | DelegStakeNotEnough => Int32 -15
      | InvalidTotalAmt => Int32 -18
      | ReDelegInvalidSSNAddr => Int32 -21
      | CantFetchRemoteImplAddr => Int32 -101
      | CantFetchRemoteBnumReq => Int32 -102
<<<<<<< HEAD
      | CompleteWithdrawalFundsMismatchAtZimpl => Int32 -201
      | CompleteWithdrawalFundsZeroAtZimpl => Int32 -201
      | CompleteWithdrawalFundsMismatchAimplZimpl => Int32 -203
=======
      | NoActiveBuffer => Int32 -103
>>>>>>> main
      end
    in
    { _exception: "Error"; code: result_code }

let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end

let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None =>
        (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end

let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg


let uint128_zero = Uint128 0
let uint128_one = Uint128 1
let uint32_zero = Uint32 0
let uint32_one = Uint32 1

<<<<<<< HEAD
(* check if withdrawal_pending[deleg] is empty *)
let is_block_deposit_map_empty =
  fun(m : Map BNum Withdrawal) =>
    let map_size = builtin size m in
    builtin eq map_size uint32_zero

let addfunds_tag = "AddFunds"
=======
let active_buffer =
  fun (l : List ByStr20) =>
  fun (lastrewardcycle : Uint32) =>
    let flist_length = @list_length ByStr20 in
    let l_length = flist_length l in
    let active = builtin rem lastrewardcycle l_length in
    let flist_nth = @list_nth ByStr20 in
    flist_nth active l
>>>>>>> main

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract AZil(
  init_azil_ssn_address               : ByStr20,
  init_proxy_staking_contract_address : ByStr20,
  init_holder_address                 : ByStr20
)
(*  Parameters *)
(* (owner     : ByStr20) *)

(* Mutable fields *)
field azil_ssn_address                : ByStr20 = init_azil_ssn_address
field proxy_staking_contract_address  : ByStr20 = init_proxy_staking_contract_address
field holder_address                  : ByStr20 = init_holder_address

field totalstakeamount: Uint128 = uint128_zero
field totaltokenamount: Uint128 = uint128_zero

field balances: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* AddressOfDeleg -> BlockNumber -> Deposit *)
field withdrawal_pending: Map ByStr20 (Map BNum Withdrawal) = Emp ByStr20 (Map BNum Withdrawal)

field tmp_current_deleg: Option ByStr20 = None {ByStr20}
field tmp_complete_withdrawal_available: Uint128 = uint128_zero
field tmp_complete_withdrawal_initiator: Option ByStr20 = None {ByStr20}

field local_bnum_req: Uint128 = Uint128 35000
field local_lastrewardcycle: Uint32 = uint32_one

(* 10 ZIL expresssed in Qa where 1 ZIL = 10^12 Qa *)
field mindelegstake: Uint128 = Uint128 10000000000000

field buffers_addresses: List ByStr20 = Nil {ByStr20}

(************************************************************)
(* @dev: Procedures                                         *)
(************************************************************)

procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

procedure FetchRemoteZimplFields()
  proxy_staking_contract_addr <- proxy_staking_contract_address;
  (* Address type cast *)
  (* TODO: seems it's possible to save gas, using type check of transition parameter *)
  (* https://scilla.readthedocs.io/en/latest/scilla-in-depth.html?highlight=remote#dynamic-typecheck-of-addresses *)
  proxyAddrTypeTest <- & proxy_staking_contract_addr as ByStr20 with contract field implementation : ByStr20 end;
  match proxyAddrTypeTest with
  | Some v =>
    implAddr <- & v.implementation;
    implAddrTypeTest <- & implAddr as ByStr20 with contract field bnum_req : Uint128, field lastrewardcycle: Uint32 end;
    match implAddrTypeTest with
    | Some z =>
      bnum_req <- & z.bnum_req;
      local_bnum_req := bnum_req;
      lrc <- & z.lastrewardcycle;
      local_lastrewardcycle := lrc
    | None =>
        e = CantFetchRemoteBnumReq;
        ThrowError e
    end
  | None =>
    e = CantFetchRemoteImplAddr;
    ThrowError e
  end
end

(************************************************************)
(* @dev: Holder actions                                     *)
(************************************************************)

procedure HolderWithdrawStakeAmt(amount: Uint128)
  holder_addr <- holder_address;
  proxy_staking_contract_addr <- proxy_staking_contract_address;

  msg = {_tag: "WithdrawStakeAmt"; _recipient: holder_addr; _amount: uint128_zero; amount: amount};
  msgs = one_msg msg;
  send msgs
end

procedure HolderCompleteWithdrawal()
  holder_addr <- holder_address;
  proxy_staking_contract_addr <- proxy_staking_contract_address;
  msg = {_tag: "CompleteWithdrawal"; _recipient: holder_addr; _amount: uint128_zero };
  msgs = one_msg msg;
  send msgs
end

(************************************************************)
(* @dev: Buffer actions                                     *)
(************************************************************)

(* @dev : To delegate the stake to the contract through buffer. *)
procedure BufferDelegate(amount: Uint128)
  FetchRemoteZimplFields;
  cycle <- local_lastrewardcycle;
  buffer_addrs <- buffers_addresses;
  buffer = active_buffer buffer_addrs cycle;

  match buffer with
  | None =>
    e = NoActiveBuffer;
    ThrowError e
  | Some buffer_addr =>
    msg = {_tag: "DelegateStake"; _recipient: buffer_addr; _amount: amount};
    msgs = one_msg msg;
    send msgs
  end
end

(************************************************************)
(* @dev: aZil actions                                     *)
(************************************************************)

<<<<<<< HEAD
procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
    msg = {_tag: tag; _recipient: recipient; _amount: amt};
    msgs = one_msg msg;
    send msgs
end

procedure FetchRemoteZimplFields()
  proxy_staking_contract_addr <- proxy_staking_contract_address;
  (* Address type cast *)
  (* TODO: seems it's possible to save gas, using type check of transition parameter *)
  (* https://scilla.readthedocs.io/en/latest/scilla-in-depth.html?highlight=remote#dynamic-typecheck-of-addresses *)
  proxyAddrTypeTest <- & proxy_staking_contract_addr as ByStr20 with contract field implementation : ByStr20 end;
  match proxyAddrTypeTest with
  | Some v =>
    implAddr <- & v.implementation;
    implAddrTypeTest <- & implAddr as ByStr20 with contract field bnum_req : Uint128, field lastrewardcycle: Uint32 end;
    match implAddrTypeTest with
    | Some z =>
      bnum_req <- & z.bnum_req;
      local_bnum_req := bnum_req;
      lrc <- & z.lastrewardcycle;
      local_lastrewardcycle := lrc
    | None =>
        e = CantFetchRemoteBnumReq;
        ThrowError e
    end
  | None =>
    e = CantFetchRemoteImplAddr;
    ThrowError e
  end
end

=======
>>>>>>> main
procedure IsDelegstakeSufficient(amount: Uint128)
  mindelegstake_l <- mindelegstake;
  suffi =  uint128_le mindelegstake_l amount;
  match suffi with
  | True =>
  | False =>
    e = DelegStakeNotEnough;
    ThrowError e
  end
end

procedure IncreaseTotalStakeAmt(amt: Uint128)
  total_stake_amt <- totalstakeamount;
  new_total_amt = builtin add total_stake_amt amt;
  totalstakeamount := new_total_amt
end

procedure IncreaseTotalTokenAmt(amt: Uint128)
  total_token_amt <- totaltokenamount;
  new_total_amt = builtin add total_token_amt amt;
  totaltokenamount := new_total_amt
end

procedure DecreaseTotalStakeAmt(amt: Uint128)
  current_amt <- totalstakeamount;
  valid = uint128_le amt current_amt;
  match valid with
  | True =>
    new_amt = builtin sub current_amt amt;
    totalstakeamount := new_amt
  | False =>
    e = InvalidTotalAmt;
    ThrowError e
  end
end

procedure DecreaseTotalTokenAmt(amt: Uint128)
  current_amt <- totaltokenamount;
  valid = uint128_le amt current_amt;
  match valid with
  | True =>
    new_amt = builtin sub current_amt amt;
    totaltokenamount := new_amt
  | False =>
    e = InvalidTotalAmt;
    ThrowError e
  end
end

(* to erase withdrawal_pending outer keys  *)
procedure CleanPendingWithdrawalDelegAddr(deleg: ByStr20)
  block_deposit_map <- withdrawal_pending[deleg];
  match block_deposit_map with
  | Some block_deposit_entry =>
    is_map_empty = is_block_deposit_map_empty block_deposit_entry;
    match is_map_empty with
    | True => (* empty map *)
      delete withdrawal_pending[deleg]
    | False => (* contains other records *)
    end
  | None => (* nothing to delete *)
  end
end

(* delete the blk num and any other external keys if the inner map is empty *)
(* for use in replace of normal delete operation to erase empty nested maps *)
procedure DeletePendingWithdrawal(deleg: ByStr20, withdraw_number: BNum)
  delete withdrawal_pending[deleg][withdraw_number];
  CleanPendingWithdrawalDelegAddr deleg
end

procedure TruncateDeleg(deleg: ByStr20)
  delete balances[deleg]
end

(* newTokens = amount * totaltokenamount / totalstakeamount *)
procedure Delegate(initiator: ByStr20, stake_amt: Uint128)
  IsDelegstakeSufficient stake_amt;

  total_token_amt <- totaltokenamount;
  current_stake_amt <- totalstakeamount;

  first_delegation = builtin eq total_token_amt uint128_zero;
  token_amt =
    match first_delegation with
    | True => stake_amt
    | False => muldiv stake_amt total_token_amt current_stake_amt
    end;

  current_token_amount <- balances[initiator];
  match current_token_amount  with
  | Some current_token_amt =>
    new_current_token_amt = builtin add current_token_amt token_amt;
    balances[initiator] := new_current_token_amt
  | None =>
    balances[initiator] := token_amt
  end;

  IncreaseTotalStakeAmt stake_amt;
  IncreaseTotalTokenAmt token_amt
end

procedure AdjustDeleg(deleg: ByStr20, total_amount: Uint128, withdraw_amount: Uint128)
  sufficient = uint128_le withdraw_amount total_amount;
  match sufficient with
  | True =>
    need_truncate =  builtin eq withdraw_amount total_amount;
    match need_truncate with
    | True =>
      (* Remove all info map recorded for this deleg *)
      TruncateDeleg deleg
    | False =>
      (* Readjust all rest deleg to this cycle *)
      rest_deleg = builtin sub total_amount withdraw_amount;
      (* rest delegate should also meet mindelegstake *)
      IsDelegstakeSufficient rest_deleg;
      TruncateDeleg deleg;
      (* Refer to transition TruncateDeleg, here we don't use Fillin transition because we *)
      (* know they are all empty, and this can reduce some gasfee *)
      balances[deleg] := rest_deleg
    end
  | False =>
    e = DelegHasNoSufficientAmt;
    ThrowError e
  end
end

procedure WithdrawalStakeAmt(initiator: ByStr20, withdraw_token_amt: Uint128)
  current_token_amount <- balances[initiator];
  azil_ssn_addr <- azil_ssn_address;

  match current_token_amount with
  | Some current_token_amt =>
    AdjustDeleg initiator current_token_amt withdraw_token_amt;

    (* Illegal withdraw amount could be handled in procedure AdjustDeleg *)
    (* Calculate token to zil to withdraw *)
    total_token_amt <- totaltokenamount;
    total_stake_amt <- totalstakeamount;
    withdraw_stake_amt = muldiv withdraw_token_amt total_stake_amt total_token_amt;

    withdrawal_bnum <- & BLOCKNUMBER;
    withdraw_pending_o <- withdrawal_pending[initiator][withdrawal_bnum];

    (* Upsert pending withdrawal *)
    match withdraw_pending_o with
    | Some (Withdrawal token stake) =>
      new_withdraw_token_amt = builtin add token withdraw_token_amt;
      new_withdraw_stake_amt = builtin add stake withdraw_stake_amt;
      pending_withdrawal = Withdrawal new_withdraw_token_amt new_withdraw_stake_amt;
      withdrawal_pending[initiator][withdrawal_bnum] := pending_withdrawal
    | None =>
      pending_withdrawal = Withdrawal withdraw_token_amt withdraw_stake_amt;
      withdrawal_pending[initiator][withdrawal_bnum] := pending_withdrawal
    end;

    e = { _eventname: "WithdrawStakeAmt"; ssn_addr: azil_ssn_addr; deleg_address: initiator; withdraw_amount:withdraw_token_amt; withdraw_stake_amount:withdraw_stake_amt };
    event e;

    (* Subtract withdrawn amounts from total counters *)
    DecreaseTotalStakeAmt withdraw_stake_amt;
    DecreaseTotalTokenAmt withdraw_token_amt;

    (* call Holder contract *)
    HolderWithdrawStakeAmt withdraw_stake_amt
  | None =>
    e = DelegDoesNotExistAtSSN;
    ThrowError e
  end
end

<<<<<<< HEAD
(* current_block > withdraw_number + bnum_req *)
procedure CalculateTotalWithdrawalIteration(withdraw: Pair BNum Withdrawal)
  current_deleg <- tmp_current_deleg;
  match current_deleg with
  | Some deleg =>
    match withdraw with
    | Pair withdraw_number withdrawal_token_stake =>
      match withdrawal_token_stake with
      | Withdrawal token_amt stake_amt =>
        current_bnum <- & BLOCKNUMBER;
        current_bnum_req <- local_bnum_req; (* local value is fetched from Zimpl *)
        bnum = builtin badd withdraw_number current_bnum_req;
        can_withdraw = builtin blt bnum current_bnum;
        match can_withdraw with
        | True =>
            DeletePendingWithdrawal deleg withdraw_number;
            current_amt <- tmp_complete_withdrawal_available;
            current_amt = builtin add current_amt stake_amt;
            tmp_complete_withdrawal_available := current_amt
        | False =>
        end
      end
    end
  | None => (* Won't reach *)
  end
end

procedure CalculateTotalWithdrawal(withdraw_initiator: ByStr20)
  FetchRemoteZimplFields;
  tmp_complete_withdrawal_available := uint128_zero;
  withdraw_map_o <- withdrawal_pending[withdraw_initiator];
  match withdraw_map_o with
  | Some withdraw_map =>
    withdraw_list = builtin to_list withdraw_map;
    (* Calculate withdrawal that can be transferred *)
    c = Some {ByStr20} withdraw_initiator;
    tmp_current_deleg := c;
    forall withdraw_list CalculateTotalWithdrawalIteration
  | None =>
    e = { _eventname: "NoPendingWithdrawal" };
    event e
  end
end


procedure CompleteWithdrawalCallBackProcess(amountZimplCallback: Uint128, amountZimplAccepted: Uint128, status: String)

  (* check that Zimpl amount are not zero, it should not go here *)
  amount_zero = builtin eq amountZimplCallback uint128_zero;
  match amount_zero with
  | False =>
    e = { _eventname: "CompleteWithdrawalFundsZeroAtZimpl"; amountZimplCallback: amountZimplCallback; amountZimplAccepted: amountZimplAccepted };
    event e;
    e = CompleteWithdrawalFundsZeroAtZimpl;
    ThrowError e
  | True =>
  end;

  (* check that Zimpl sent us correct data *)
  amount_eq = builtin eq amountZimplCallback amountZimplAccepted;
  match amount_eq with
  | False =>
    e = { _eventname: "CompleteWithdrawalFundsMismatchAtZimpl"; amountZimplCallback: amountZimplCallback; amountZimplAccepted: amountZimplAccepted };
    event e;
    e = CompleteWithdrawalFundsMismatchAtZimpl;
    ThrowError e
  | True =>
  end;

  (* check Aimpl-calculated withdrawal amount against of Zimpl *)
  withdraw_amt <- tmp_complete_withdrawal_available;
  amount_eq = builtin eq withdraw_amt amountZimplAccepted;
  match amount_eq with
  | False =>
    e = { _eventname: "CompleteWithdrawalFundsMismatchAimplZimpl"; amountAimpl: withdraw_amt; amountZimplAccepted: amountZimplAccepted };
    event e;
    e = CompleteWithdrawalFundsMismatchAimplZimpl;
    ThrowError e
  | True =>
  end;

  (* if no exception thrown till here, we can accept funds *)
  accept;

  option_withdrawal_initiator <- tmp_complete_withdrawal_initiator;
  match option_withdrawal_initiator with
  | Some withdrawal_initiator =>
    e = { _eventname: "CompleteWithdrawal"; amount: withdraw_amt };
    event e;
    TransferFunds addfunds_tag withdraw_amt withdrawal_initiator;
    msg_to_delegator = {_tag : "CompleteWithdrawalSuccessCallBack"; _recipient : withdrawal_initiator; _amount : uint128_zero;
    amount : withdraw_amt};
    msg = one_msg msg_to_delegator;
    send msg
  | None =>
  end

end

=======
>>>>>>> main
(************************************************************)
(* @dev: Admin actions                                      *)
(************************************************************)

transition ChangeHolderAddress(address: ByStr20)
  holder_address := address;

  e = { _eventname: "ChangeHolderAddress"; address: address };
  event e
end

transition ChangeProxyContractAddress(address: ByStr20)
  proxy_staking_contract_address := address;

  e = { _eventname: "ChangeProxyContractAddress"; address: address };
  event e
end

transition ChangeBuffers(new_buffers: List ByStr20)
  buffers_addresses := new_buffers
end

transition GetCurrentBuffer()
  FetchRemoteZimplFields;
  cycle <- local_lastrewardcycle;
  buffer_addrs <- buffers_addresses;
  buffer = active_buffer buffer_addrs cycle;

  match buffer with
  | None =>
    e = {_eventname: "GetCurrentBufferFailure"};
    event e
  | Some buffer_addr =>
    e = {_eventname: "GetCurrentBufferSuccess"; buffer: buffer_addr};
    event e
  end
end

transition IncreaseTotalStakeAmount(amount: Uint128)
  (* TODO: should we send ZIL here and accept, or just increase by input parameter? *)
  IncreaseTotalStakeAmt amount;

  e = { _eventname: "IncreaseTotalStakeAmount"; amount: amount };
  event e
end

(* @dev: Set the staking parameters of contract. *)
(* @param min_deleg_stake: New mindelegstake value *)
transition UpdateStakingParameters(min_deleg_stake: Uint128)
  mindelegstake := min_deleg_stake;

  e = { _eventname: "UpdateStakingParameters"; min_deleg_stake: min_deleg_stake };
  event e
end

(************************************************************)
(* @dev: Deposit undelegated zil, use our node              *)
(************************************************************)
transition DelegateStake()
  accept;
  stake_amt = _amount;
  initiator = _sender;

  BufferDelegate stake_amt;
  Delegate initiator stake_amt;

  e = { _eventname: "DelegateStake"; delegator: initiator; amount: stake_amt };
  event e;

  msg_to_delegator = {_tag : "DelegateStakeSuccessCallBack"; _recipient : initiator; _amount : uint128_zero; amount : stake_amt};
  msg = one_msg msg_to_delegator;
  send msg
end

(* @param amount: Amount of tokens to withdraw, ZIL stake amount to withdraw will be calculated basing on this parameter *)
transition WithdrawStakeAmt(amount: Uint128)
  initiator = _sender;
  azil_ssn_addr <- azil_ssn_address;

  (* first we do all checks, then call Holder on success within procedure*)
  WithdrawalStakeAmt initiator amount;

  (* TODO: we sending Azil callback, but ignoring Zimpl callback completely. Should we? *)
  msg_to_delegator = {_tag : "WithdrawStakeAmtSuccessCallBack"; _recipient : initiator; _amount : uint128_zero;
  ssnaddr : azil_ssn_addr; amount : amount};
  msg = one_msg msg_to_delegator;
  send msg
end

(********************************************************************************)
(*                    CompleteWithdrawal Flow                                   *)
(*                                                                              *)
(* 1) Azil implemetattion calls Holder->CompleteWithdrawal()                    *)
(* 2) Holder calls Zproxy->CompleteWithdrawal()                                 *)
(* 3) Zimpl do its work, then few options are possible:                         *)
(*   a) it issues NoPendingWithdrawal event                                     *)
(*   b) it calls back Holder->CompleteWithdrawalNoUnbondedStakeCallBack()       *)
(*   c) it calls subsequentally:                                                *)
(*     * Holder->AddFunds(_amount), Holder should accept it                     *)
(*     * Holder->CompleteWithdrawalSuccessCallBack(amount),                     *)
(*                                                                              *)
(* In case of (3c):                                                             *)
(*                                                                              *)
(* 1) Holder calls Azil->CompleteWithdrawalCallBack("success", _amount, amount) *)
(* 2) Azil in this callback do all checks, then if                              *)
(*   a) OK => Azil calls Initiator->callbackOK(funds),                          *)
(*   b) ERROR => Azil calls Initiator->callbackError(zero)                      *)
(*                                                                              *)
(* Completely successful chaincall will looks like                              *)
(* Arbitrage->Aproxy->Aimpl->Holder->Zproxy->Zimpl->Holder->Aimpl->Arbitrage    *)
(*                                                                              *)
(********************************************************************************)

transition CompleteWithdrawal()
  (* TODO: IsArbitrage; *)
  initiator = _sender;

  (* go through pending withdrawals, calculate total of those which have unbonding period completed *)
  CalculateTotalWithdrawal initiator;

  withdraw_amt <- tmp_complete_withdrawal_available;
  zero_withdraw = builtin eq withdraw_amt uint128_zero;
  match zero_withdraw with
  | True =>
    (* There is nothing to withdraw, we don't need to call Zimpl. *)
    (* Even Zimpl has something to withdraw, we'll get amount mistmatch error. *)
    (* Se we'll call Zimpl next time when we'll have something to withdraw here. *)
    e = { _eventname: "NoUnbondedStake" };
    event e;
    msg_to_delegator = {_tag : "CompleteWithdrawalNoUnbondedStakeCallBack"; _recipient : initiator; _amount : uint128_zero;
    amount : uint128_zero};
    msg = one_msg msg_to_delegator;
    send msg
  | False =>
    e = { _eventname: "CompleteWithdrawal"; amount: withdraw_amt };
    event e;
    (* there is something ready to withdraw completely, so we'll start the flow *)
    (* save initiator of transition to use later in chaincall *)
    c = Some {ByStr20} initiator;
    tmp_complete_withdrawal_initiator := c;
    HolderCompleteWithdrawal
  end

end

transition CompleteWithdrawalSuccessCallBack(amountZimplCallback: Uint128, amountZimplAccepted: Uint128)
  status = "Success";
  CompleteWithdrawalCallBackProcess amountZimplCallback amountZimplAccepted status
end

transition CompleteWithdrawalNoUnbondedCallBack(amount: Uint128)
  (* If we got this callback from <-Holder<-Zimpl, it means that something goes wrong *)
  (* Because we don't call ->Holder->Zproxy->Zimpl in case we have no unbonded withdrawals here in Aimpl *)
  status = "NoUnbonded";
  CompleteWithdrawalCallBackProcess amount amount status
end

(************************************************************)
(* @dev: Returns an account zil amount                      *)
(************************************************************)
transition ZilBalanceOf(address: ByStr20)
  total_token_amt <- totaltokenamount;
  total_stake_amt <- totalstakeamount;

  current_token_amount <- balances[address];

  balance =
    match current_token_amount with
    | Some current_token_amt => muldiv current_token_amt total_stake_amt total_token_amt
    | None => uint128_zero
    end;

  e = { _eventname: "ZilBalanceOf"; address: address; balance: balance };
  event e;

  msg_to_sender = { _tag : "ZilBalanceOfCallBack"; _recipient : _sender; _amount : uint128_zero; address: address; balance : balance};
  msgs = one_msg msg_to_sender;
  send msgs
end
