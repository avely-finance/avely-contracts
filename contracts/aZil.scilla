scilla_version 0

import ListUtils IntUtils BoolUtils

(***************************************************)
(*               Associated library                *)
(***************************************************)
library AZil

type Withdrawal =
  | Withdrawal of Uint128 Uint128

type Error =
  | AdminValidationFailed
  | BufferAddrUnknown
  | BufferNoActive
  | BufferOrHolderValidationFailed
  | BuffersAlreadySet
  | CantFetchZimplBufferExistsAtSSN
  | CantFetchZimplFields
  | ClaimWithdrawalNoUnbonded
  | CompleteWithdrawalFundsMismatch
  | DelegAddrUnknown
  | DelegDoesNotExistAtSSN
  | DelegHasBufferedDeposit
  | DelegHasNoSufficientAmt
  | DelegStakeFundsMismatch
  | DelegStakeNotEnough
  | InvalidTotalAmt
  | HolderAlreadySet
  | NotPaused
  | Paused
  | StagingAdminNotExists
  | StagingAdminValidationFailed

let make_error =
  fun (result: Error) =>
    let result_code =
      match result with
      | AdminValidationFailed           => "AdminValidationFailed"
      | BufferAddrUnknown               => "BufferAddrUnknown"
      | BufferNoActive                  => "BufferNoActive"
      | BufferOrHolderValidationFailed  => "BufferOrHolderValidationFailed"
      | BuffersAlreadySet               => "BuffersAlreadySet"
      | CantFetchZimplBufferExistsAtSSN => "CantFetchZimplBufferExistsAtSSN"
      | CantFetchZimplFields            => "CantFetchZimplFields"
      | ClaimWithdrawalNoUnbonded       => "ClaimWithdrawalNoUnbonded"
      | CompleteWithdrawalFundsMismatch => "CompleteWithdrawalFundsMismatch"
      | DelegAddrUnknown                => "DelegAddrUnknown"
      | DelegDoesNotExistAtSSN          => "DelegDoesNotExistAtSSN"
      | DelegHasBufferedDeposit         => "DelegHasBufferedDeposit"
      | DelegHasNoSufficientAmt         => "DelegHasNoSufficientAmt"
      | DelegStakeFundsMismatch         => "DelegStakeFundsMismatch"
      | DelegStakeNotEnough             => "DelegStakeNotEnough"
      | InvalidTotalAmt                 => "InvalidTotalAmt"
      | HolderAlreadySet                => "HolderAlreadySet"
      | Paused                          => "Paused"
      | NotPaused                       => "NotPaused"
      | StagingAdminNotExists           => "StagingAdminNotExists"
      | StagingAdminValidationFailed    => "StagingAdminValidationFailed"
      end
    in
    { _exception: "Error"; code: result_code }

let bystr20_eq : ByStr20 -> ByStr20 -> Bool =
  fun (x : ByStr20) =>
  fun (y : ByStr20) =>
    builtin eq x y

let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end

let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None =>
        (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end

let one_msg =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let false = False
let true = True
let uint128_zero = Uint128 0
let uint128_one = Uint128 1
let uint32_zero = Uint32 0
let uint32_one = Uint32 1
let bystr20_zero = 0x0000000000000000000000000000000000000000

let option_value =
  tfun 'A =>
  fun (default: 'A) =>
  fun (opt_val: Option 'A) =>
    match opt_val with
    | Some v => v
    | None => default
    end

let option_uint32_value =
  let f = @option_value Uint32 in
  f uint32_zero

let addfunds_tag = "AddFunds"

let get_active_buffer_addr =
  fun (l : List ByStr20) =>
  fun (lastrewardcycle : Uint32) =>
    let flist_length = @list_length ByStr20 in
    let l_length = flist_length l in
    let active = builtin rem lastrewardcycle l_length in
    let flist_nth = @list_nth ByStr20 in
    flist_nth active l

let leave_unbonded =
  fun (current_bnum: BNum) =>
  fun (bnum_req_delta: Uint128) =>
  fun (blist: List BNum) =>
    let is_unbonded =
      fun (withdraw_inited_bnum: BNum) =>
        let btest = builtin badd withdraw_inited_bnum bnum_req_delta in
        builtin blt btest current_bnum in
    let filterBNum = @list_filter BNum in
    filterBNum is_unbonded blist

let is_buffer_addr =
  fun(l: List ByStr20) =>
  fun(addr: ByStr20) =>
    let feq = bystr20_eq addr in
    let flist_exists = @list_exists ByStr20 in
    flist_exists feq l

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract AZil(
  init_admin_address        : ByStr20,
  init_azil_ssn_address     : ByStr20,
  init_zimpl_address        : ByStr20
)

field admin_address         : ByStr20 = init_admin_address
field azil_ssn_address      : ByStr20 = init_azil_ssn_address
field zimpl_address         : ByStr20 = init_zimpl_address
field holder_address        : ByStr20 = bystr20_zero
field buffers_addresses     : List ByStr20 = Nil {ByStr20}
field staging_admin_address : Option ByStr20 = None {ByStr20}

field is_paused: Bool = True

(* 10 ZIL expresssed in Qa where 1 ZIL = 10^12 Qa *)
field mindelegstake     : Uint128 = Uint128 10000000000000
field totalstakeamount  : Uint128 = uint128_zero
field totaltokenamount  : Uint128 = uint128_zero
field autorestakeamount : Uint128 = uint128_zero

field balances: Map ByStr20 Uint128 = Emp ByStr20 Uint128

(* BlockNumber -> AddressOfDeleg ->  Withdrawal of Token:Uint128 Stake:Uint128 *)
field withdrawal_pending: Map BNum (Map ByStr20 Withdrawal) = Emp BNum (Map ByStr20 Withdrawal)

(* AddressOfDeleg ->  Deposit *)
field withdrawal_unbonded: Map ByStr20 Withdrawal = Emp ByStr20 Withdrawal

(* Keeps track of the cycle number when a deleg last buffered deposit its delegate *)
(* AddressOfDeleg -> CycleNumberWhenLastDeposit *)
field last_buf_deposit_cycle_deleg: Map ByStr20 Uint32 = Emp ByStr20 Uint32

field tmp_delegator: Option ByStr20 = None {ByStr20}
field tmp_stake_delegate_amount: Uint128 = uint128_zero
field tmp_complete_withdrawal_available: Uint128 = uint128_zero
field tmp_buffer_exists_at_ssn: Uint32 = uint32_zero

field local_bnum_req: Uint128 = Uint128 35000
field local_lastrewardcycle: Uint32 = uint32_one

(************************************************************)
(* @dev: Procedures                                         *)
(************************************************************)

procedure ThrowError(err: Error)
  e = make_error err;
  throw e
end

procedure RequireAdmin()
  contractadmin_tmp <- admin_address;
  is_admin = builtin eq _sender contractadmin_tmp;
  match is_admin with
  | True  =>
  | False =>
    e = AdminValidationFailed;
    ThrowError e
  end
end

procedure RequireNotPaused()
  paused <- is_paused;
  match paused with
  | False =>
  | True =>
    error = Paused;
    ThrowError error
  end
end

procedure RequireBufferOrHolder()
  buffers_addrs <- buffers_addresses;
  is_buffer = is_buffer_addr buffers_addrs _sender;

  holder <- holder_address;
  is_holder = builtin eq _sender holder;

  is_buffer_or_holder = orb is_buffer is_holder;

  match is_buffer_or_holder with
  | True  =>
  | False =>
    e = BufferOrHolderValidationFailed;
    ThrowError e
  end
end

procedure TransferFunds(tag: String, amt: Uint128, recipient: ByStr20)
  msg = {_tag: tag; _recipient: recipient; _amount: amt};
  msgs = one_msg msg;
  send msgs
end

procedure FetchRemoteZimplFields()
  implAddr <- zimpl_address;
  implAddrTypeTest <- & implAddr as ByStr20 with contract field bnum_req : Uint128, field lastrewardcycle: Uint32 end;
  match implAddrTypeTest with
  | Some z =>
    bnum_req <- & z.bnum_req;
    local_bnum_req := bnum_req;
    lrc <- & z.lastrewardcycle;
    local_lastrewardcycle := lrc
  | None =>
    e = CantFetchZimplFields;
    ThrowError e
  end
end

procedure FetchRemoteBufferExistsAtSSN(buffer_addr: ByStr20)
  implAddr <- zimpl_address;
  implAddrTypeTest <- & implAddr as ByStr20 with contract field deposit_amt_deleg: Map ByStr20 (Map ByStr20 Uint128) end;
  match implAddrTypeTest with
  | Some z =>
    o_deposit_amt_deleg <- & z.deposit_amt_deleg[buffer_addr];
    match o_deposit_amt_deleg with
    | Some amt =>
      tmp_buffer_exists_at_ssn := uint32_one
    | None =>
      tmp_buffer_exists_at_ssn := uint32_zero
    end
  | None =>
      e = CantFetchZimplBufferExistsAtSSN;
      ThrowError e
  end
end

(************************************************************)
(* @dev: Holder & Buffer actions                            *)
(************************************************************)

procedure HolderWithdrawStakeAmt(amount: Uint128)
  holder_addr <- holder_address;
  msg = {_tag: "WithdrawStakeAmt"; _recipient: holder_addr; _amount: uint128_zero; amount: amount};
  msgs = one_msg msg;
  send msgs
end

procedure HolderCompleteWithdrawal()
  holder_addr <- holder_address;
  msg = { _tag: "CompleteWithdrawal"; _recipient: holder_addr; _amount: uint128_zero };
  msgs = one_msg msg;
  send msgs
end

(* @dev : To delegate the stake to the contract through buffer. *)
procedure BufferDelegate(amount: Uint128)
  FetchRemoteZimplFields;
  cycle <- local_lastrewardcycle;
  buffer_addrs <- buffers_addresses;
  buffer = get_active_buffer_addr buffer_addrs cycle;

  match buffer with
  | None =>
    e = BufferNoActive;
    ThrowError e
  | Some buffer_addr =>
    msg = {_tag: "DelegateStake"; _recipient: buffer_addr; _amount: amount};
    msgs = one_msg msg;
    send msgs
  end
end

procedure ClaimRewards(addr: ByStr20)
  msg = { _tag: "ClaimRewards"; _recipient: addr; _amount: uint128_zero };
  msgs = one_msg msg;
  send msgs
end

procedure RequestDelegatorSwap(from: ByStr20, to: ByStr20)
  msg = { _tag: "RequestDelegatorSwap"; _recipient: from; _amount: uint128_zero; new_deleg_addr: to};
  msgs = one_msg msg;
  send msgs
end

procedure ConfirmDelegatorSwap(from: ByStr20, to: ByStr20)
  msg = { _tag: "ConfirmDelegatorSwap"; _recipient: to; _amount: uint128_zero; requestor: from};
  msgs = one_msg msg;
  send msgs
end

(************************************************************)
(* @dev: aZil actions                                       *)
(************************************************************)

procedure IsDelegStakeSufficient(amount: Uint128)
  mindelegstake_l <- mindelegstake;
  suffi =  uint128_le mindelegstake_l amount;
  match suffi with
  | True =>
  | False =>
    e = DelegStakeNotEnough;
    ThrowError e
  end
end

procedure IncreaseTotalStakeAmt(amt: Uint128)
  total_stake_amt <- totalstakeamount;
  new_total_amt = builtin add total_stake_amt amt;
  totalstakeamount := new_total_amt
end

procedure IncreaseTotalTokenAmt(amt: Uint128)
  total_token_amt <- totaltokenamount;
  new_total_amt = builtin add total_token_amt amt;
  totaltokenamount := new_total_amt
end

procedure IncreaseAutoRestakeAmt(amt: Uint128)
  auto_restake_amt <- autorestakeamount;
  new_total_amt = builtin add auto_restake_amt amt;
  autorestakeamount := new_total_amt
end

procedure DecreaseTotalStakeAmt(amt: Uint128)
  current_amt <- totalstakeamount;
  valid = uint128_le amt current_amt;
  match valid with
  | True =>
    new_amt = builtin sub current_amt amt;
    totalstakeamount := new_amt
  | False =>
    e = InvalidTotalAmt;
    ThrowError e
  end
end

procedure DecreaseTotalTokenAmt(amt: Uint128)
  current_amt <- totaltokenamount;
  valid = uint128_le amt current_amt;
  match valid with
  | True =>
    new_amt = builtin sub current_amt amt;
    totaltokenamount := new_amt
  | False =>
    e = InvalidTotalAmt;
    ThrowError e
  end
end

procedure TruncateDeleg(deleg: ByStr20)
  delete balances[deleg];
  delete last_buf_deposit_cycle_deleg[deleg]
end

(* newTokens = amount * totaltokenamount / totalstakeamount *)
procedure UpdateTokenBalance(initiator: ByStr20, stake_amt: Uint128)
  total_token_amt <- totaltokenamount;
  current_stake_amt <- totalstakeamount;

  first_delegation = builtin eq total_token_amt uint128_zero;
  token_amt =
    match first_delegation with
    | True => stake_amt
    | False => muldiv stake_amt total_token_amt current_stake_amt
    end;

  current_token_amount <- balances[initiator];
  match current_token_amount  with
  | Some current_token_amt =>
    new_current_token_amt = builtin add current_token_amt token_amt;
    balances[initiator] := new_current_token_amt
  | None =>
    balances[initiator] := token_amt
  end;

  FetchRemoteZimplFields;
  lrc <- local_lastrewardcycle;

  last_buf_deposit_cycle_deleg[initiator] := lrc;

  IncreaseTotalStakeAmt stake_amt;
  IncreaseTotalTokenAmt token_amt
end

procedure AssertNoBufferedDeposit(deleg: ByStr20)
  FetchRemoteZimplFields;
  ldcd_o <- last_buf_deposit_cycle_deleg[deleg];
  ldcd = option_uint32_value ldcd_o;
  lrc <- local_lastrewardcycle;

  has_buffered = uint32_le lrc ldcd;
  match has_buffered with
  | True =>
    e = DelegHasBufferedDeposit;
    ThrowError e
  | False =>
  end
end

procedure AdjustDeleg(deleg: ByStr20, total_amount: Uint128, withdraw_amount: Uint128)
  sufficient = uint128_le withdraw_amount total_amount;
  match sufficient with
  | True =>
    need_truncate =  builtin eq withdraw_amount total_amount;
    match need_truncate with
    | True =>
      (* Remove all info map recorded for this deleg *)
      TruncateDeleg deleg
    | False =>
      (* Readjust all rest deleg to this cycle *)
      rest_deleg = builtin sub total_amount withdraw_amount;
      (* rest delegate should also meet mindelegstake *)
      IsDelegStakeSufficient rest_deleg;
      TruncateDeleg deleg;
      (* Refer to transition TruncateDeleg, here we don't use Fillin transition because we *)
      (* know they are all empty, and this can reduce some gasfee *)
      balances[deleg] := rest_deleg
    end
  | False =>
    e = DelegHasNoSufficientAmt;
    ThrowError e
  end
end

procedure WithdrawalStakeAmt(initiator: ByStr20, withdraw_token_amt: Uint128)
  current_token_amount <- balances[initiator];
  azil_ssn_addr <- azil_ssn_address;

  match current_token_amount with
  | Some current_token_amt =>
    AssertNoBufferedDeposit initiator;
    AdjustDeleg initiator current_token_amt withdraw_token_amt;

    (* Illegal withdraw amount could be handled in procedure AdjustDeleg *)
    (* Calculate token to zil to withdraw *)
    total_token_amt <- totaltokenamount;
    total_stake_amt <- totalstakeamount;
    withdraw_stake_amt = muldiv withdraw_token_amt total_stake_amt total_token_amt;

    withdrawal_bnum <- & BLOCKNUMBER;
    withdraw_pending_o <- withdrawal_pending[withdrawal_bnum][initiator];

    (* Upsert pending withdrawal *)
    match withdraw_pending_o with
    | Some (Withdrawal token stake) =>
      new_withdraw_token_amt = builtin add token withdraw_token_amt;
      new_withdraw_stake_amt = builtin add stake withdraw_stake_amt;
      pending_withdrawal = Withdrawal new_withdraw_token_amt new_withdraw_stake_amt;
      withdrawal_pending[withdrawal_bnum][initiator] := pending_withdrawal
    | None =>
      pending_withdrawal = Withdrawal withdraw_token_amt withdraw_stake_amt;
      withdrawal_pending[withdrawal_bnum][initiator] := pending_withdrawal
    end;

    e = { _eventname: "WithdrawStakeAmt"; ssn_addr: azil_ssn_addr; deleg_address: initiator; withdraw_amount:withdraw_token_amt; withdraw_stake_amount:withdraw_stake_amt };
    event e;

    (* Subtract withdrawn amounts from total counters *)
    DecreaseTotalStakeAmt withdraw_stake_amt;
    DecreaseTotalTokenAmt withdraw_token_amt;

    (* call Holder contract *)
    HolderWithdrawStakeAmt withdraw_stake_amt
  | None =>
    e = DelegDoesNotExistAtSSN;
    ThrowError e
  end
end

(* We can receive two types of callback: *)
(*   1. Autorestake. We need to increase internal total ZIL balance. *)
(*   2. User delegate. We need to change a user balance  *)
procedure ProcessDelegateStakeSuccessCallBack(delegator: ByStr20, amount: Uint128)
  is_autorestake = builtin eq delegator _this_address;

  match is_autorestake with
  | True =>
    IncreaseTotalStakeAmt amount;
    autorestakeamount := uint128_zero
  | False =>
    UpdateTokenBalance delegator amount;

    (* Reset tmp variables *)
    tmp_stake_delegate_amount := uint128_zero;
    reset_delegator = None {ByStr20};
    tmp_delegator := reset_delegator;


    msg_to_delegator = {_tag : "DelegateStakeSuccessCallBack"; _recipient : delegator; _amount : uint128_zero; amount : amount};
    msg = one_msg msg_to_delegator;
    send msg
  end
end

(*
  tmp_complete_withdrawal_available += Withdrawal.stake
  withdrawal_unbonded[delegator] += Withdrawal; //create if none
*)
procedure CalculateTotalWithdrawalBlock(deleg_withdrawal: Pair ByStr20 Withdrawal)
  match deleg_withdrawal with
  | Pair delegator withdrawal =>
    match withdrawal with
    | Withdrawal withdraw_token_amt withdraw_stake_amt =>
      (* update total stake withdraw amount *)
      current_amt <- tmp_complete_withdrawal_available;
      current_amt = builtin add current_amt withdraw_stake_amt;
      tmp_complete_withdrawal_available := current_amt;
      (* upsert unbonded withdrawal for delegator *)
      withdrawal_unbonded_o <- withdrawal_unbonded[delegator];
      match withdrawal_unbonded_o with
      | Some (Withdrawal token stake) =>
        updated_token = builtin add token withdraw_token_amt;
        updated_stake = builtin add stake withdraw_stake_amt;
        unbonded_withdrawal = Withdrawal updated_token updated_stake;
        withdrawal_unbonded[delegator] := unbonded_withdrawal
      | None =>
        unbonded_withdrawal = Withdrawal withdraw_token_amt withdraw_stake_amt;
        withdrawal_unbonded[delegator] := unbonded_withdrawal
      end
    end
  end
end

(*
  foreach withdrawal_pending[bnum] as Pair deleg Withdrawal
  then delete withdrawal_pending[bnum]
*)
procedure CalculateTotalWithdrawal(bnum: BNum)
  map_deleg_amount_o <- withdrawal_pending[bnum];
  match map_deleg_amount_o with
  | Some map_deleg_amount =>
    list_deleg_amount = builtin to_list map_deleg_amount;
    forall list_deleg_amount CalculateTotalWithdrawalBlock
  | None =>
  end;
  delete withdrawal_pending[bnum]
end

(************************************************************)
(* @dev: Admin actions                                      *)
(************************************************************)

transition Pause()
  RequireAdmin;
  RequireNotPaused;

  is_paused := true;
  e = { _eventname: "Pause"; is_paused: uint32_one };
  event e
end

transition UnPause()
  RequireAdmin;

  paused <- is_paused;
  match paused with
  | True =>
  | False =>
    error = NotPaused;
    ThrowError error
  end;

  is_paused := false;
  e = { _eventname: "UnPause"; is_paused: uint32_zero };
  event e
end

transition ChangeAdmin(new_admin: ByStr20)
  RequireAdmin;
  var_staging_admin = Some {ByStr20} new_admin;
  staging_admin_address := var_staging_admin;
  var_admin_address <- admin_address;
  e = {_eventname: "ChangeAdmin"; current_admin: var_admin_address; new_admin: new_admin};
  event e
end

transition ClaimAdmin()
  staging_admin_o <- staging_admin_address;
  match staging_admin_o with
  | Some staging_admin =>
    is_stagingadmin = builtin eq staging_admin _sender;
    match is_stagingadmin with
    | True =>
      admin_address := _sender;
      tmp_staging_admin = None {ByStr20};
      staging_admin_address := tmp_staging_admin;
      e = {_eventname: "ClaimAdmin"; new_admin: _sender};
      event e
    | False =>
      e = StagingAdminValidationFailed;
      ThrowError e
    end
  | None =>
    e = StagingAdminNotExists;
    ThrowError e
  end
end

transition SetHolderAddress(address: ByStr20)
  (* TODO RequirePaused; ?*)
  var_holder_addr <- holder_address;
  is_holder_empty = builtin eq var_holder_addr bystr20_zero;
  match is_holder_empty with
  | True =>
    holder_address := address;
    e = { _eventname: "SetHolderAddress"; address: address };
    event e
  | False =>
    e = HolderAlreadySet;
    ThrowError e
  end
end

transition SetBuffers(new_buffers: List ByStr20)
  (* TODO RequirePaused; ?*)

  var_buffers_addrs <- buffers_addresses;
  blen =
    let llen = @list_length ByStr20 in
    llen var_buffers_addrs;

  is_buffers_empty = builtin eq blen uint32_zero;
  match is_buffers_empty with
  | False =>
    e = BuffersAlreadySet;
    ThrowError e
  | True =>
    buffers_addresses := new_buffers
  end

end

transition GetCurrentBuffer()
  RequireAdmin;
  FetchRemoteZimplFields;
  cycle <- local_lastrewardcycle;
  buffer_addrs <- buffers_addresses;
  buffer = get_active_buffer_addr buffer_addrs cycle;

  match buffer with
  | None =>
    e = {_eventname: "GetCurrentBufferFailure"};
    event e
  | Some buffer_addr =>
    e = {_eventname: "GetCurrentBufferSuccess"; buffer: buffer_addr};
    event e
  end
end

transition DrainBuffer(buffer_addr: ByStr20)
  RequireAdmin;
  buffers_addrs <- buffers_addresses;
  is_buffer = is_buffer_addr buffers_addrs buffer_addr;

  match is_buffer with
  | True =>
    FetchRemoteBufferExistsAtSSN buffer_addr;
    var_buffer_exists <- tmp_buffer_exists_at_ssn;
    is_exists = builtin eq var_buffer_exists uint32_one;
    match is_exists with
    | True =>
      holder_addr <- holder_address;
      ClaimRewards buffer_addr;
      ClaimRewards holder_addr;
      RequestDelegatorSwap buffer_addr holder_addr;
      ConfirmDelegatorSwap buffer_addr holder_addr
    | False =>
      holder_addr <- holder_address;
      ClaimRewards holder_addr
    end
  | False =>
    e = BufferAddrUnknown;
    ThrowError e
  end;
  tmp_buffer_exists_at_ssn := uint32_zero
end

transition ClaimRewardsSuccessCallBack()
  RequireBufferOrHolder;
  accept;
  IncreaseAutoRestakeAmt _amount
end

transition PerformAutoRestake()
  RequireAdmin;

  auto_restake_amt <- autorestakeamount;
  IsDelegStakeSufficient auto_restake_amt;

  is_zero = builtin eq auto_restake_amt uint128_zero;
  match is_zero with
  | True =>
  | False =>
    tmp_stake_delegate_amount := auto_restake_amt;
    o_delegator = Some {ByStr20} _this_address;
    tmp_delegator := o_delegator;

    BufferDelegate auto_restake_amt
  end
end

transition IncreaseAutoRestakeAmount()
  RequireAdmin;
  accept;
  amount = _amount;

  IncreaseAutoRestakeAmt amount;

  e = { _eventname: "IncreaseAutoRestakeAmount"; amount: amount };
  event e
end

(* @dev: Set the staking parameters of contract. *)
(* @param min_deleg_stake: New mindelegstake value *)
transition UpdateStakingParameters(min_deleg_stake: Uint128)
  RequireAdmin;
  mindelegstake := min_deleg_stake;

  e = { _eventname: "UpdateStakingParameters"; min_deleg_stake: min_deleg_stake };
  event e
end

(************************************************************)
(* @dev: Deposit undelegated zil, use our node              *)
(************************************************************)
transition DelegateStake()
  RequireNotPaused;

  accept;
  stake_amt = _amount;

  IsDelegStakeSufficient stake_amt;

  tmp_stake_delegate_amount := stake_amt;
  o_delegator = Some {ByStr20} _sender;
  tmp_delegator := o_delegator;

  BufferDelegate stake_amt
end

transition DelegateStakeSuccessCallBack(amount: Uint128)
  RequireBufferOrHolder;

  stake_delegate_amt <- tmp_stake_delegate_amount;
  o_delegator <- tmp_delegator;

  amount_eq = builtin eq amount stake_delegate_amt;

  match amount_eq with
  | False =>
    e = DelegStakeFundsMismatch;
    ThrowError e
  | True =>
    match o_delegator with
    | Some delegator =>
      ProcessDelegateStakeSuccessCallBack delegator amount;

      e = { _eventname: "DelegateStake"; delegator: delegator; amount: amount };
      event e
    | None =>
      e = DelegAddrUnknown;
      ThrowError e
    end
  end
end

(********************************************************************************)
(*                    ClaimWithdrawal Flow                                      *)
(*                                                                              *)
(* 1) Offchain worker calls Aimpl->ClaimWithdrawal()                            *)
(* 1) Aimpl calls Holder->CompleteWithdrawal()                                  *)
(* 2) Holder calls Zproxy->CompleteWithdrawal()                                 *)
(* 3) Zimpl do its work, then few options are possible:                         *)
(*   a) it issues NoPendingWithdrawal event                                     *)
(*   b) it calls back Holder->CompleteWithdrawalNoUnbondedStakeCallBack()       *)
(*   c) it calls subsequentally:                                                *)
(*     * Holder->AddFunds(_amount), Holder should accept it                     *)
(*     * Holder->CompleteWithdrawalSuccessCallBack(amount),                     *)
(* In case of (3c):                                                             *)
(*                                                                              *)
(* 1) Holder calls Azil->CompleteWithdrawalSuccessCallBack(_amount)             *)
(* 2) Azil accepts; then check _amount with tmp_complete_withdrawal_available   *)
(*   a) OK => workflow finished                                                 *)
(*   b) ERROR => exception                                                      *)
(*                                                                              *)
(* Completely successful chaincall will looks like                              *)
(* Worker->Aimpl->Holder->Zproxy->Zimpl->Holder->Aimpl                          *)
(*                                                                              *)
(********************************************************************************)

transition ClaimWithdrawal(blocks_to_withdraw: List BNum)
  RequireAdmin;
  FetchRemoteZimplFields;

  current_bnum <- & BLOCKNUMBER;
  current_bnum_req <- local_bnum_req;
  unbonded = leave_unbonded current_bnum current_bnum_req blocks_to_withdraw;

  tmp_complete_withdrawal_available := uint128_zero;
  forall unbonded CalculateTotalWithdrawal;

  withdraw_stake_amt <- tmp_complete_withdrawal_available;
  zero_withdraw = builtin eq withdraw_stake_amt uint128_zero;
  match zero_withdraw with
  | True =>
    e = ClaimWithdrawalNoUnbonded;
    ThrowError e
  | False =>
    (* there is something ready to withdraw completely, so we'll start the flow *)
    HolderCompleteWithdrawal
  end
end

(* @param amount: Amount of tokens to withdraw, ZIL stake amount to withdraw will be calculated basing on this parameter *)
transition WithdrawStakeAmt(amount: Uint128)
  RequireNotPaused;

  azil_ssn_addr <- azil_ssn_address;

  (* first we do all checks, then call Holder on success within procedure *)
  WithdrawalStakeAmt _sender amount;

  msg_to_delegator = {_tag : "WithdrawStakeAmtSuccessCallBack"; _recipient : _sender; _amount : uint128_zero;
    ssnaddr : azil_ssn_addr; amount : amount};
  msg = one_msg msg_to_delegator;
  send msg
end

transition CompleteWithdrawal()
  RequireNotPaused;

  wu <- withdrawal_unbonded[_sender];
  match wu with
  | Some (Withdrawal wtoken wstake) =>
    delete withdrawal_unbonded[_sender];
    e = { _eventname: "CompleteWithdrawal"; delegator: _sender; amount: wstake };
    event e;
    TransferFunds addfunds_tag wstake _sender;
    msg_to_delegator = {_tag : "CompleteWithdrawalSuccessCallBack"; _recipient : _sender; _amount : uint128_zero;
      amount : wstake};
    msg = one_msg msg_to_delegator;
    send msg
  | None =>
    msg_to_delegator = {_tag : "CompleteWithdrawalNoUnbondedStakeCallBack"; _recipient : _sender; _amount : uint128_zero;
    amount : uint128_zero};
    msg = one_msg msg_to_delegator;
    send msg;
    e = { _eventname: "NoUnbondedStake" };
    event e
  end
end

transition CompleteWithdrawalSuccessCallBack()
  RequireBufferOrHolder;

  accept;
  amount = _amount;

  (* check Aimpl-calculated withdrawal amount against of Zimpl *)
  withdraw_amt <- tmp_complete_withdrawal_available;
  amount_eq = builtin eq withdraw_amt amount;
  match amount_eq with
  | False =>
    e = { _eventname: "CompleteWithdrawalFundsMismatch"; amountAimpl: withdraw_amt; amounthZimpl: amount };
    event e;
    e = CompleteWithdrawalFundsMismatch;
    ThrowError e
  | True =>
  end;

  tmp_complete_withdrawal_available := uint128_zero

end

(************************************************************)
(* @dev: Returns an account zil amount                      *)
(************************************************************)
transition ZilBalanceOf(address: ByStr20)
  RequireNotPaused;

  total_token_amt <- totaltokenamount;
  total_stake_amt <- totalstakeamount;

  current_token_amount <- balances[address];

  balance =
    match current_token_amount with
    | Some current_token_amt => muldiv current_token_amt total_stake_amt total_token_amt
    | None => uint128_zero
    end;

  e = { _eventname: "ZilBalanceOf"; address: address; balance: balance };
  event e;

  msg_to_sender = { _tag : "ZilBalanceOfCallBack"; _recipient : _sender; _amount : uint128_zero; address: address; balance : balance};
  msgs = one_msg msg_to_sender;
  send msgs
end
